<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Scheduled TMX Exports </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Scheduled TMX Exports ">
    <meta name="generator" content="docfx 2.56.7.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="scheduled-tmx-exports">Scheduled TMX Exports</h1>

<p>You can also export the content of a server TM to a <em>*.tmx</em> file. Here, the same considerations apply as for the <em>.tmx</em> import, i.e. the export operation, too, could be disrupted by latencies in the WAN connection. This is why exports are run as scheduled tasks. When running an export from a file-based TM, you select the location where the <em>*.tmx</em> document should be created on your local hard disk. When running an export from a server TM you do not select a file path. Instead, the export is run as a scheduled task, and the <em>*.tmx</em> file can then be downloaded once the export has finished.</p>
<h2 id="add-a-new-class">Add a New Class</h2>
<p>Start by adding a new class to your project called ServerExporter. Within this class, you implement a public function called ExportToTmx, which takes the TM Server object and the TM name as parameters.</p>
<h2 id="open-the-tm-and-create-an-exporter-object">Open the TM and Create an Exporter Object</h2>
<p>First, open the TM from which the export should take place. Programmatically, this is tantamount to creating a TM object by applying the <code>GetTranslationMemory</code> method to the TM Server object. This requires the full path to the TM including the organization name, e.g. /Organization Name/TM Name.</p>
<pre><code>if (!orgName.StartsWith(&quot;/&quot;)) orgName = &quot;/&quot; + orgName;
if (!orgName.EndsWith(&quot;/&quot;)) orgName += &quot;/&quot;;
ServerBasedTranslationMemory tm = tmServer.GetTranslationMemory(
    orgName + tmName, TranslationMemoryProperties.All);
</code></pre><p>Next, create an exporter object:</p>
<pre><code>ScheduledTranslationMemoryExportOperation exporter = new ScheduledTranslationMemoryExportOperation(
    this.GetLanguageDirection(tm, CultureInfo.GetCultureInfo(&quot;en-US&quot;), CultureInfo.GetCultureInfo(&quot;de-DE&quot;)));
</code></pre><p>The TMX export file will contain two languages (e.g. en-US -&gt; de-DE). Use the following separate function to verify whether the selected TM supports this language direction and to set the languages for the export:</p>
<pre><code>private ServerBasedTranslationMemoryLanguageDirection GetLanguageDirection(ServerBasedTranslationMemory tm, CultureInfo source, CultureInfo target)
{
    foreach (ServerBasedTranslationMemoryLanguageDirection item in tm.LanguageDirections)
    {
        if (item.SourceLanguage == source &amp;&amp; item.TargetLanguage == target)
        {
            return item;
        }
    }

    throw new Exception(&quot;Requested direction doesn&#39;t exist.&quot;);
}
</code></pre><p>Configure the Export Settings
In the next step, you may configure the export settings such as the <code>ChunkSize</code>, which determines the number of TUs that are processed at a given time. Especially when using slower Internet connections, it may be better to choose a smaller chunk size. Note that the default chunk size is 50 (<code>DefaultTranslationUnitChunkSize</code>), the maximum chunk size is 200 (<code>MaxTranslationUnitChunkSize</code>). Another (boolean) parameter that you may set is ContinueOnError. True means that when errors are encountered during the export (e.g. due to an invalid TU), the process should still continue by exporting the remaining (valid) TUs.</p>
<pre><code>exporter.ChunkSize = 25;
exporter.ContinueOnError = true;
</code></pre><h2 id="continue-or-wait">Continue or Wait</h2>
<p>In the next step you determine whether the export operation should be refreshed or not Through <code>ScheduledOperationStatus</code> you can determine the current status of the export operation. When the operation is, for example, Aborted or Cancelled, the process should not continue. However, when the status of the operation is, for example, Queued or Recovering, the process should be refreshed (Refresh).</p>
<pre><code>exporter.Queue();
exporter.Refresh();

bool continueWaiting = true;
while (continueWaiting)
{
    switch (exporter.Status)
    {
        case ScheduledOperationStatus.Abort:
        case ScheduledOperationStatus.Aborted:
        case ScheduledOperationStatus.Cancel:
        case ScheduledOperationStatus.Cancelled:
        case ScheduledOperationStatus.Completed:
        case ScheduledOperationStatus.Error:
            continueWaiting = false;
            break;
        case ScheduledOperationStatus.Aborting:
        case ScheduledOperationStatus.Allocated:
        case ScheduledOperationStatus.Cancelling:
        case ScheduledOperationStatus.NotSet:
        case ScheduledOperationStatus.Queued:
        case ScheduledOperationStatus.Recovered:
        case ScheduledOperationStatus.Recovering:
        case ScheduledOperationStatus.Recovery:
            continueWaiting = true;
            exporter.Refresh();
            break;
        default:
            continueWaiting = false;
            break;
    }
}
</code></pre><h2 id="complete-the-process">Complete the Process</h2>
<p>At the end you can use the ScheduledOperationStatus class to ascertain whether the export operation has finished, or not. When the status of the operation is Completed, the user should be notified on the successful completion of the process. If the status is Error, the user should also be notified accordingly by throwing an exception message.</p>
<pre><code>if (exporter.Status == ScheduledOperationStatus.Completed)
{
    using (Stream outputStream  = new FileStream(exportFilePath, FileMode.Create))
    {
        exporter.DownloadExport(outputStream, exporter_Downloaded);
    }
    MessageBox.Show(&quot;Export successfuly finished.&quot;);
}
else if (exporter.Status == ScheduledOperationStatus.Error)
{
    MessageBox.Show(exporter.ErrorMessage);
}
else
{
    MessageBox.Show(&quot;Export did not finish.&quot;);
}
</code></pre><h2 id="putting-it-all-together">Putting it All Together</h2>
<p>The complete class should now look as shown below:</p>
<pre><code>namespace Sdl.SDK.LanguagePlatform.Samples.TmAutomation
{
    using System;
    using System.IO;
    using System.Globalization;
    using System.Windows.Forms;
    using Sdl.LanguagePlatform.TranslationMemoryApi;

    public class ServerExporter
    {
        public void ExportToTmx(TranslationProviderServer tmServer, string orgName, string tmName, string exportFilePath)
        {
            #region &quot;OpenTm&quot;
            if (!orgName.StartsWith(&quot;/&quot;)) orgName = &quot;/&quot; + orgName;
            if (!orgName.EndsWith(&quot;/&quot;)) orgName += &quot;/&quot;;
            ServerBasedTranslationMemory tm = tmServer.GetTranslationMemory(
                orgName + tmName, TranslationMemoryProperties.All);
            #endregion

            #region &quot;exporter&quot;
            ScheduledTranslationMemoryExportOperation exporter = new ScheduledTranslationMemoryExportOperation(
                this.GetLanguageDirection(tm, CultureInfo.GetCultureInfo(&quot;en-US&quot;), CultureInfo.GetCultureInfo(&quot;de-DE&quot;)));
            #endregion

            #region &quot;settings&quot;
            exporter.ChunkSize = 25;
            exporter.ContinueOnError = true;
            #endregion

            #region &quot;wait&quot;
            exporter.Queue();
            exporter.Refresh();

            bool continueWaiting = true;
            while (continueWaiting)
            {
                switch (exporter.Status)
                {
                    case ScheduledOperationStatus.Abort:
                    case ScheduledOperationStatus.Aborted:
                    case ScheduledOperationStatus.Cancel:
                    case ScheduledOperationStatus.Cancelled:
                    case ScheduledOperationStatus.Completed:
                    case ScheduledOperationStatus.Error:
                        continueWaiting = false;
                        break;
                    case ScheduledOperationStatus.Aborting:
                    case ScheduledOperationStatus.Allocated:
                    case ScheduledOperationStatus.Cancelling:
                    case ScheduledOperationStatus.NotSet:
                    case ScheduledOperationStatus.Queued:
                    case ScheduledOperationStatus.Recovered:
                    case ScheduledOperationStatus.Recovering:
                    case ScheduledOperationStatus.Recovery:
                        continueWaiting = true;
                        exporter.Refresh();
                        break;
                    default:
                        continueWaiting = false;
                        break;
                }
            }
            #endregion

            #region &quot;completed&quot;
            if (exporter.Status == ScheduledOperationStatus.Completed)
            {
                using (Stream outputStream  = new FileStream(exportFilePath, FileMode.Create))
                {
                    exporter.DownloadExport(outputStream, exporter_Downloaded);
                }
                MessageBox.Show(&quot;Export successfuly finished.&quot;);
            }
            else if (exporter.Status == ScheduledOperationStatus.Error)
            {
                MessageBox.Show(exporter.ErrorMessage);
            }
            else
            {
                MessageBox.Show(&quot;Export did not finish.&quot;);
            }
            #endregion
        }

        #region &quot;LanguageDirection&quot;
        private ServerBasedTranslationMemoryLanguageDirection GetLanguageDirection(ServerBasedTranslationMemory tm, CultureInfo source, CultureInfo target)
        {
            foreach (ServerBasedTranslationMemoryLanguageDirection item in tm.LanguageDirections)
            {
                if (item.SourceLanguage == source &amp;&amp; item.TargetLanguage == target)
                {
                    return item;
                }
            }

            throw new Exception(&quot;Requested direction doesn&#39;t exist.&quot;);
        }
        #endregion

        private void exporter_Downloaded(object sender, FileTransferEventArgs e)
        {
            MessageBox.Show(&quot;Transferred - &quot; + e.BytesTransferred.ToString() + &quot; out of &quot; + e.TotalBytes.ToString() + &quot; bytes\r\n&quot;);
            e.Cancel = false;
        }

    }
}
</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/sdl/studio-api-docs/blob/main/apiconcepts/translationmemory/scheduled_tmx_exports.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
